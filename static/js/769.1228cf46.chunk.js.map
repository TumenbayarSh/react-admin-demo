{"version":3,"file":"static/js/769.1228cf46.chunk.js","mappings":"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","sources":["../../../packages/ra-data-graphql/src/introspection.ts","../../../packages/ra-data-graphql/src/buildApolloClient.ts","../../../packages/ra-data-graphql/src/constants.ts","../../../packages/ra-data-graphql/src/index.ts","../../../packages/ra-data-graphql-simple/src/getFinalType.ts","../../../packages/ra-data-graphql-simple/src/isList.ts","../../../packages/ra-data-graphql-simple/src/buildVariables.ts","../../../packages/ra-data-graphql-simple/src/isRequired.ts","../../../packages/ra-data-graphql-simple/src/buildGqlQuery.ts","../../../packages/ra-data-graphql-simple/src/getResponseParser.ts","../../../packages/ra-data-graphql-simple/src/buildQuery.ts","../../../packages/ra-data-graphql-simple/src/index.ts","dataProvider/graphql.ts"],"sourcesContent":["import {\n    getIntrospectionQuery,\n    IntrospectionObjectType,\n    IntrospectionQuery,\n    IntrospectionSchema,\n    IntrospectionType,\n} from 'graphql';\nimport { ApolloClient, gql } from '@apollo/client';\n\nimport { ALL_TYPES } from './constants';\n\nlet introspectionPromise;\n\n/**\n * @param {ApolloClient} client The Apollo client\n * @param {Object} options The introspection options\n */\nexport const introspectSchema = async (\n    client: ApolloClient<unknown>,\n    options: IntrospectionOptions\n) => {\n    if (introspectionPromise) {\n        return introspectionPromise;\n    }\n    introspectionPromise = runSchemaIntrospection(client, options);\n    return introspectionPromise;\n};\n\nexport type IntrospectionOptions = {\n    schema?: IntrospectionSchema;\n    operationNames: {\n        [key: string]: (type: IntrospectionType) => string;\n    };\n    exclude?: string[] | ((type: IntrospectionType) => boolean);\n    include?: string[] | ((type: IntrospectionType) => boolean);\n};\n\nexport type IntrospectedResource = {\n    type: IntrospectionObjectType;\n};\nexport type IntrospectionResult = {\n    types: IntrospectionType[];\n    queries: IntrospectionObjectType[];\n    resources: IntrospectedResource[];\n    schema: IntrospectionSchema;\n};\n\nconst runSchemaIntrospection = async (\n    client: ApolloClient<unknown>,\n    options: IntrospectionOptions\n) => {\n    const schema = options.schema ? options.schema : await fetchSchema(client);\n    const queries = getQueriesFromSchema(schema);\n    const types = getTypesFromSchema(schema);\n    const resources = getResources(types, queries, options);\n\n    return {\n        types,\n        queries,\n        resources,\n        schema,\n    };\n};\n\nconst fetchSchema = (\n    client: ApolloClient<unknown>\n): Promise<IntrospectionSchema> => {\n    return client\n        .query<IntrospectionQuery>({\n            fetchPolicy: 'network-only',\n            query: gql`\n                ${getIntrospectionQuery()}\n            `,\n        })\n        .then(({ data: { __schema } }) => __schema);\n};\n\nconst getQueriesFromSchema = (\n    schema: IntrospectionSchema\n): IntrospectionObjectType[] => {\n    return schema.types.reduce((acc, type) => {\n        if (\n            type.name !== schema.queryType?.name &&\n            type.name !== schema.mutationType?.name &&\n            (type as IntrospectionObjectType).fields\n        ) {\n            return acc;\n        }\n\n        return [...acc, ...((type as IntrospectionObjectType).fields || [])];\n    }, []);\n};\n\nconst getTypesFromSchema = (schema: IntrospectionSchema) => {\n    return schema.types.filter(\n        type =>\n            type.name !== (schema.queryType && schema.queryType.name) &&\n            type.name !== (schema.mutationType && schema.mutationType.name)\n    );\n};\n\nconst getResources = (\n    types: IntrospectionType[],\n    queries: IntrospectionObjectType[],\n    options: IntrospectionOptions\n): IntrospectedResource[] => {\n    const filteredResources = types.filter(type =>\n        isResource(type, queries, options)\n    );\n    return filteredResources.map(type =>\n        buildResource(type as IntrospectionObjectType, queries, options)\n    );\n};\n\nconst isResource = (\n    type: IntrospectionType,\n    queries: IntrospectionObjectType[],\n    options: IntrospectionOptions\n) => {\n    if (isResourceIncluded(type, options)) return true;\n    if (isResourceExcluded(type, options)) return false;\n\n    const operations = Object.keys(options.operationNames).map(operation =>\n        options.operationNames[operation](type)\n    );\n\n    const hasAtLeastOneOperation = operations.some(operation =>\n        queries.find(({ name }) => name === operation)\n    );\n\n    return hasAtLeastOneOperation;\n};\n\nexport const isResourceIncluded = (\n    type: IntrospectionType,\n    { include }: Partial<IntrospectionOptions> = {}\n) => {\n    if (Array.isArray(include)) {\n        return include.includes(type.name);\n    }\n\n    if (typeof include === 'function') {\n        return include(type);\n    }\n\n    return false;\n};\n\nexport const isResourceExcluded = (\n    type: IntrospectionType,\n    { exclude }: Partial<IntrospectionOptions> = {}\n) => {\n    if (Array.isArray(exclude)) {\n        return exclude.includes(type.name);\n    }\n\n    if (typeof exclude === 'function') {\n        return exclude(type);\n    }\n\n    return false;\n};\n\nconst buildResource = (\n    type: IntrospectionObjectType,\n    queries: IntrospectionObjectType[],\n    options: IntrospectionOptions\n): IntrospectedResource => {\n    return ALL_TYPES.reduce(\n        (acc, raFetchMethod) => {\n            const query = queries.find(\n                ({ name }) =>\n                    options.operationNames[raFetchMethod] &&\n                    name === options.operationNames[raFetchMethod](type)\n            );\n\n            if (!query) return acc;\n\n            return {\n                ...acc,\n                [raFetchMethod]: query,\n            };\n        },\n        { type }\n    );\n};\n","import {\n    ApolloClient,\n    ApolloClientOptions,\n    HttpLink,\n    InMemoryCache,\n} from '@apollo/client';\n\nexport default (options: Partial<ApolloClientOptions<unknown>>) => {\n    if (!options) {\n        return new ApolloClient({\n            cache: new InMemoryCache().restore({}),\n        });\n    }\n\n    const {\n        cache = new InMemoryCache().restore({}),\n        uri,\n        link = !!uri ? new HttpLink({ uri }) : undefined,\n        ...otherOptions\n    } = options;\n\n    return new ApolloClient({\n        link,\n        cache,\n        ...otherOptions,\n    });\n};\n","import {\n    GET_LIST,\n    GET_ONE,\n    GET_MANY,\n    GET_MANY_REFERENCE,\n    CREATE,\n    UPDATE,\n    UPDATE_MANY,\n    DELETE,\n    DELETE_MANY,\n} from 'ra-core';\n\nexport const QUERY_TYPES = [GET_LIST, GET_MANY, GET_MANY_REFERENCE, GET_ONE];\nexport const MUTATION_TYPES = [\n    CREATE,\n    UPDATE,\n    DELETE,\n    UPDATE_MANY,\n    DELETE_MANY,\n];\nexport const ALL_TYPES = QUERY_TYPES.concat(MUTATION_TYPES);\n","import merge from 'lodash/merge';\nimport get from 'lodash/get';\nimport pluralize from 'pluralize';\nimport {\n    DataProvider,\n    HttpError,\n    GET_LIST,\n    GET_ONE,\n    GET_MANY,\n    GET_MANY_REFERENCE,\n    CREATE,\n    UPDATE,\n    DELETE,\n    DELETE_MANY,\n    UPDATE_MANY,\n} from 'ra-core';\nimport {\n    ApolloClient,\n    ApolloClientOptions,\n    ApolloError,\n    ApolloQueryResult,\n    MutationOptions,\n    WatchQueryOptions,\n    QueryOptions,\n    OperationVariables,\n    ServerError,\n} from '@apollo/client';\n\nimport buildApolloClient from './buildApolloClient';\nimport {\n    QUERY_TYPES as INNER_QUERY_TYPES,\n    MUTATION_TYPES as INNER_MUTATION_TYPES,\n    ALL_TYPES as INNER_ALL_TYPES,\n} from './constants';\nimport {\n    introspectSchema,\n    IntrospectionOptions,\n    IntrospectionResult,\n} from './introspection';\n\nexport * from './introspection';\nexport const QUERY_TYPES = INNER_QUERY_TYPES;\nexport const MUTATION_TYPES = INNER_MUTATION_TYPES;\nexport const ALL_TYPES = INNER_ALL_TYPES;\n\nconst RaFetchMethodMap = {\n    getList: GET_LIST,\n    getMany: GET_MANY,\n    getManyReference: GET_MANY_REFERENCE,\n    getOne: GET_ONE,\n    create: CREATE,\n    delete: DELETE,\n    deleteMany: DELETE_MANY,\n    update: UPDATE,\n    updateMany: UPDATE_MANY,\n};\nconst defaultOptions = {\n    resolveIntrospection: introspectSchema,\n    introspection: {\n        operationNames: {\n            [GET_LIST]: resource => `all${pluralize(resource.name)}`,\n            [GET_ONE]: resource => `${resource.name}`,\n            [GET_MANY]: resource => `all${pluralize(resource.name)}`,\n            [GET_MANY_REFERENCE]: resource => `all${pluralize(resource.name)}`,\n            [CREATE]: resource => `create${resource.name}`,\n            [UPDATE]: resource => `update${resource.name}`,\n            [DELETE]: resource => `delete${resource.name}`,\n        },\n        exclude: undefined,\n        include: undefined,\n    },\n};\n\nconst getOptions = (\n    options: GetQueryOptions | GetMutationOptions | GetWatchQueryOptions,\n    raFetchMethod: string,\n    resource: string\n) => {\n    if (typeof options === 'function') {\n        return options(resource, raFetchMethod);\n    }\n\n    return options;\n};\n\nexport type BuildQueryResult = QueryOptions<OperationVariables, any> & {\n    parseResponse: (response: ApolloQueryResult<any>) => any;\n};\n\nexport type BuildQuery = (\n    name: string,\n    resource: string,\n    params: any\n) => BuildQueryResult;\n\nexport type BuildQueryFactory = (\n    introspectionResults: IntrospectionResult\n) => BuildQuery;\n\nexport type GetQueryOptions = (\n    resource: string,\n    raFetchMethod: string\n) => Partial<QueryOptions<OperationVariables, any>>;\n\nexport type GetMutationOptions = (\n    resource: string,\n    raFetchMethod: string\n) => Partial<MutationOptions<OperationVariables, any>>;\n\nexport type GetWatchQueryOptions = (\n    resource: string,\n    raFetchMethod: string\n) => Partial<WatchQueryOptions<OperationVariables, any>>;\n\nexport type Options = {\n    client?: ApolloClient<unknown>;\n    clientOptions?: Partial<ApolloClientOptions<unknown>>;\n    introspection?: false | IntrospectionOptions;\n    override?: {\n        [key: string]: (params: any) => BuildQueryResult;\n    };\n    buildQuery: BuildQueryFactory;\n    query?: GetQueryOptions;\n    mutation?: GetMutationOptions;\n    watchQuery?: GetWatchQueryOptions;\n};\n\nexport default async (options: Options): Promise<DataProvider> => {\n    const {\n        client: clientObject,\n        clientOptions,\n        introspection,\n        resolveIntrospection,\n        buildQuery: buildQueryFactory,\n        override = {},\n        ...otherOptions\n    } = merge({}, defaultOptions, options);\n\n    if (override && process.env.NODE_ENV === 'production') {\n        console.warn(\n            // eslint-disable-line\n            'The override option is deprecated. You should instead wrap the buildQuery function provided by the dataProvider you use.'\n        );\n    }\n\n    const client = clientObject || buildApolloClient(clientOptions);\n\n    let introspectionResults;\n\n    const raDataProvider = new Proxy<DataProvider>(defaultDataProvider, {\n        get: (target, name) => {\n            if (typeof name === 'symbol' || name === 'then') {\n                return;\n            }\n            const raFetchMethod = RaFetchMethodMap[name];\n            return async (resource, params) => {\n                if (introspection) {\n                    introspectionResults = await resolveIntrospection(\n                        client,\n                        introspection\n                    );\n                }\n\n                const buildQuery = buildQueryFactory(introspectionResults);\n                const overriddenBuildQuery = get(\n                    override,\n                    `${resource}.${raFetchMethod}`\n                );\n\n                const { parseResponse, ...query } = overriddenBuildQuery\n                    ? {\n                          ...buildQuery(raFetchMethod, resource, params),\n                          ...overriddenBuildQuery(params),\n                      }\n                    : buildQuery(raFetchMethod, resource, params);\n\n                const operation = getQueryOperation(query.query);\n\n                if (operation === 'query') {\n                    const apolloQuery = {\n                        ...query,\n                        fetchPolicy: 'network-only',\n                        ...getOptions(\n                            otherOptions.query,\n                            raFetchMethod,\n                            resource\n                        ),\n                    };\n\n                    return (\n                        client\n                            // @ts-ignore\n                            .query(apolloQuery)\n                            .then(response => parseResponse(response))\n                            .catch(handleError)\n                    );\n                }\n\n                const apolloQuery = {\n                    mutation: query.query,\n                    variables: query.variables,\n                    ...getOptions(\n                        otherOptions.mutation,\n                        raFetchMethod,\n                        resource\n                    ),\n                };\n\n                return (\n                    client\n                        // @ts-ignore\n                        .mutate(apolloQuery)\n                        .then(parseResponse)\n                        .catch(handleError)\n                );\n            };\n        },\n    });\n\n    return raDataProvider;\n};\n\nconst handleError = (error: ApolloError) => {\n    if (error?.networkError as ServerError) {\n        throw new HttpError(\n            (error?.networkError as ServerError)?.message,\n            (error?.networkError as ServerError)?.statusCode\n        );\n    }\n\n    throw new HttpError(error.message, 200, error);\n};\n\nconst getQueryOperation = query => {\n    if (query && query.definitions && query.definitions.length > 0) {\n        return query.definitions[0].operation;\n    }\n\n    throw new Error('Unable to determine the query operation');\n};\n\n// Only used to initialize proxy\nconst defaultDataProvider = {\n    create: () => Promise.resolve({ data: null }), // avoids adding a context in tests\n    delete: () => Promise.resolve({ data: null }), // avoids adding a context in tests\n    deleteMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n    getList: () => Promise.resolve({ data: [], total: 0 }), // avoids adding a context in tests\n    getMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n    getManyReference: () => Promise.resolve({ data: [], total: 0 }), // avoids adding a context in tests\n    getOne: () => Promise.resolve({ data: null }), // avoids adding a context in tests\n    update: () => Promise.resolve({ data: null }), // avoids adding a context in tests\n    updateMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n};\n","import {\n    IntrospectionType,\n    IntrospectionTypeRef,\n    IntrospectionNonNullTypeRef,\n    TypeKind,\n} from 'graphql';\n\n/**\n * Ensure we get the real type even if the root type is NON_NULL or LIST\n * @param {GraphQLType} type\n */\nconst getFinalType = (\n    type: IntrospectionType | IntrospectionNonNullTypeRef | IntrospectionTypeRef\n) => {\n    if (type.kind === TypeKind.NON_NULL || type.kind === TypeKind.LIST) {\n        return getFinalType(type.ofType);\n    }\n\n    return type;\n};\n\nexport default getFinalType;\n","import {\n    IntrospectionType,\n    IntrospectionTypeRef,\n    IntrospectionNonNullTypeRef,\n    TypeKind,\n} from 'graphql';\n\nconst isList = (\n    type: IntrospectionType | IntrospectionNonNullTypeRef | IntrospectionTypeRef\n) => {\n    if (type.kind === TypeKind.NON_NULL) {\n        return isList(type.ofType);\n    }\n\n    return type.kind === TypeKind.LIST;\n};\n\nexport default isList;\n","/* eslint-disable default-case */\nimport {\n    IntrospectionField,\n    IntrospectionInputObjectType,\n    IntrospectionNamedTypeRef,\n    IntrospectionNonNullTypeRef,\n    IntrospectionType,\n} from 'graphql';\nimport {\n    GET_LIST,\n    GET_ONE,\n    GET_MANY,\n    GET_MANY_REFERENCE,\n    CREATE,\n    UPDATE,\n    DELETE,\n} from 'ra-core';\nimport { IntrospectionResult, IntrospectedResource } from 'ra-data-graphql';\n\nimport getFinalType from './getFinalType';\nimport isList from './isList';\n\nexport default (introspectionResults: IntrospectionResult) => (\n    resource: IntrospectedResource,\n    raFetchMethod: string,\n    params: any,\n    queryType: IntrospectionField\n) => {\n    const preparedParams = prepareParams(\n        params,\n        queryType,\n        introspectionResults\n    );\n\n    switch (raFetchMethod) {\n        case GET_LIST: {\n            return buildGetListVariables(introspectionResults)(\n                resource,\n                raFetchMethod,\n                preparedParams\n            );\n        }\n        case GET_MANY:\n            return {\n                filter: { ids: preparedParams.ids },\n            };\n        case GET_MANY_REFERENCE: {\n            let variables = buildGetListVariables(introspectionResults)(\n                resource,\n                raFetchMethod,\n                preparedParams\n            );\n\n            variables.filter = {\n                ...variables.filter,\n                [preparedParams.target]: preparedParams.id,\n            };\n\n            return variables;\n        }\n        case GET_ONE:\n        case DELETE:\n            return {\n                id: preparedParams.id,\n            };\n        case CREATE:\n        case UPDATE: {\n            return buildCreateUpdateVariables(\n                resource,\n                raFetchMethod,\n                preparedParams,\n                queryType\n            );\n        }\n    }\n};\n\nconst sanitizeValue = (type: IntrospectionType, value: any) => {\n    if (type.name === 'Int') {\n        return parseInt(value, 10);\n    }\n\n    if (type.name === 'Float') {\n        return parseFloat(value);\n    }\n\n    return value;\n};\n\nconst castType = (\n    value: any,\n    type: IntrospectionType | IntrospectionNonNullTypeRef\n) => {\n    const realType = type.kind === 'NON_NULL' ? type.ofType : type;\n    switch (\n        `${realType.kind}:${(realType as IntrospectionNamedTypeRef).name}`\n    ) {\n        case 'SCALAR:Int':\n            return Number(value);\n\n        case 'SCALAR:String':\n            return String(value);\n\n        case 'SCALAR:Boolean':\n            return Boolean(value);\n\n        default:\n            return value;\n    }\n};\n\nconst prepareParams = (\n    params: any,\n    queryType: Partial<IntrospectionField>,\n    introspectionResults: IntrospectionResult\n) => {\n    const result = {};\n\n    if (!params) {\n        return params;\n    }\n\n    Object.keys(params).forEach(key => {\n        const param = params[key];\n        let arg = null;\n\n        if (!param) {\n            result[key] = param;\n            return;\n        }\n\n        if (queryType && Array.isArray(queryType.args)) {\n            arg = queryType.args.find(item => item.name === key);\n        }\n\n        if (param instanceof File) {\n            result[key] = param;\n            return;\n        }\n\n        if (param instanceof Date) {\n            result[key] = param.toISOString();\n            return;\n        }\n\n        if (\n            param instanceof Object &&\n            !Array.isArray(param) &&\n            arg &&\n            arg.type.kind === 'INPUT_OBJECT'\n        ) {\n            const args = (introspectionResults.types.find(\n                item =>\n                    item.kind === arg.type.kind && item.name === arg.type.name\n            ) as IntrospectionInputObjectType).inputFields;\n            result[key] = prepareParams(param, { args }, introspectionResults);\n            return;\n        }\n\n        if (\n            param instanceof Object &&\n            !(param instanceof Date) &&\n            !Array.isArray(param)\n        ) {\n            result[key] = prepareParams(param, queryType, introspectionResults);\n            return;\n        }\n\n        if (!arg) {\n            result[key] = param;\n            return;\n        }\n\n        result[key] = castType(param, arg.type);\n    });\n\n    return result;\n};\n\nconst buildGetListVariables = (introspectionResults: IntrospectionResult) => (\n    resource: IntrospectedResource,\n    raFetchMethod: string,\n    params: any\n) => {\n    let variables: Partial<{\n        filter: { [key: string]: any };\n        page: number;\n        perPage: number;\n        sortField: string;\n        sortOrder: string;\n    }> = { filter: {} };\n    if (params.filter) {\n        variables.filter = Object.keys(params.filter).reduce((acc, key) => {\n            if (key === 'ids') {\n                return { ...acc, ids: params.filter[key] };\n            }\n\n            if (typeof params.filter[key] === 'object') {\n                const type = introspectionResults.types.find(\n                    t => t.name === `${resource.type.name}Filter`\n                );\n                const filterSome = (type as IntrospectionInputObjectType)?.inputFields?.find(\n                    t => t.name === `${key}_some`\n                );\n\n                if (filterSome) {\n                    const filter = Object.keys(params.filter[key]).reduce(\n                        (acc, k) => ({\n                            ...acc,\n                            [`${k}_in`]: params.filter[key][k],\n                        }),\n                        {}\n                    );\n                    return { ...acc, [`${key}_some`]: filter };\n                }\n            }\n\n            const parts = key.split('.');\n\n            if (parts.length > 1) {\n                if (parts[1] === 'id') {\n                    const type = introspectionResults.types.find(\n                        t => t.name === `${resource.type.name}Filter`\n                    );\n                    const filterSome = (type as IntrospectionInputObjectType)?.inputFields?.find(\n                        t => t.name === `${parts[0]}_some`\n                    );\n\n                    if (filterSome) {\n                        return {\n                            ...acc,\n                            [`${parts[0]}_some`]: { id: params.filter[key] },\n                        };\n                    }\n\n                    return { ...acc, [parts[0]]: { id: params.filter[key] } };\n                }\n\n                const resourceField = resource.type.fields.find(\n                    f => f.name === parts[0]\n                );\n                const type = getFinalType(resourceField.type);\n                return {\n                    ...acc,\n                    [key]: sanitizeValue(type, params.filter[key]),\n                };\n            }\n\n            const resourceField = resource.type.fields.find(\n                f => f.name === key\n            );\n\n            if (resourceField) {\n                const type = getFinalType(resourceField.type);\n                const isAList = isList(resourceField.type);\n\n                if (isAList) {\n                    return {\n                        ...acc,\n                        [key]: Array.isArray(params.filter[key])\n                            ? params.filter[key].map(value =>\n                                  sanitizeValue(type, value)\n                              )\n                            : sanitizeValue(type, [params.filter[key]]),\n                    };\n                }\n\n                return {\n                    ...acc,\n                    [key]: sanitizeValue(type, params.filter[key]),\n                };\n            }\n\n            return { ...acc, [key]: params.filter[key] };\n        }, {});\n    }\n\n    if (params.pagination) {\n        variables.page = parseInt(params.pagination.page, 10) - 1;\n        variables.perPage = parseInt(params.pagination.perPage, 10);\n    }\n\n    if (params.sort) {\n        variables.sortField = params.sort.field;\n        variables.sortOrder = params.sort.order;\n    }\n\n    return variables;\n};\n\nconst buildCreateUpdateVariables = (\n    resource: IntrospectedResource,\n    raFetchMethod,\n    { id, data }: any,\n    queryType: IntrospectionField\n) =>\n    Object.keys(data).reduce(\n        (acc, key) => {\n            if (Array.isArray(data[key])) {\n                const arg = queryType.args.find(a => a.name === `${key}Ids`);\n\n                if (arg) {\n                    return {\n                        ...acc,\n                        [`${key}Ids`]: data[key].map(({ id }) => id),\n                    };\n                }\n            }\n\n            if (typeof data[key] === 'object') {\n                const arg = queryType.args.find(a => a.name === `${key}Id`);\n\n                if (arg) {\n                    return {\n                        ...acc,\n                        [`${key}Id`]: data[key].id,\n                    };\n                }\n            }\n\n            return {\n                ...acc,\n                [key]: data[key],\n            };\n        },\n        { id }\n    );\n","import {\n    IntrospectionType,\n    IntrospectionListTypeRef,\n    IntrospectionTypeRef,\n    TypeKind,\n} from 'graphql';\n\nconst isRequired = (\n    type: IntrospectionType | IntrospectionListTypeRef | IntrospectionTypeRef\n) => {\n    if (type.kind === TypeKind.LIST) {\n        return isRequired(type.ofType);\n    }\n\n    return type.kind === TypeKind.NON_NULL;\n};\n\nexport default isRequired;\n","import { GET_LIST, GET_MANY, GET_MANY_REFERENCE, DELETE } from 'ra-core';\nimport {\n    QUERY_TYPES,\n    IntrospectionResult,\n    IntrospectedResource,\n} from 'ra-data-graphql';\nimport {\n    ArgumentNode,\n    IntrospectionField,\n    IntrospectionInputValue,\n    IntrospectionNamedTypeRef,\n    IntrospectionObjectType,\n    IntrospectionUnionType,\n    TypeKind,\n    TypeNode,\n    VariableDefinitionNode,\n} from 'graphql';\nimport * as gqlTypes from 'graphql-ast-types-browser';\n\nimport getFinalType from './getFinalType';\nimport isList from './isList';\nimport isRequired from './isRequired';\n\nexport default (introspectionResults: IntrospectionResult) => (\n    resource: IntrospectedResource,\n    raFetchMethod: string,\n    queryType: IntrospectionField,\n    variables: any\n) => {\n    const { sortField, sortOrder, ...metaVariables } = variables;\n    const apolloArgs = buildApolloArgs(queryType, variables);\n    const args = buildArgs(queryType, variables);\n    const metaArgs = buildArgs(queryType, metaVariables);\n    const fields = buildFields(introspectionResults)(resource.type.fields);\n\n    if (\n        raFetchMethod === GET_LIST ||\n        raFetchMethod === GET_MANY ||\n        raFetchMethod === GET_MANY_REFERENCE\n    ) {\n        return gqlTypes.document([\n            gqlTypes.operationDefinition(\n                'query',\n                gqlTypes.selectionSet([\n                    gqlTypes.field(\n                        gqlTypes.name(queryType.name),\n                        gqlTypes.name('items'),\n                        args,\n                        null,\n                        gqlTypes.selectionSet(fields)\n                    ),\n                    gqlTypes.field(\n                        gqlTypes.name(`_${queryType.name}Meta`),\n                        gqlTypes.name('total'),\n                        metaArgs,\n                        null,\n                        gqlTypes.selectionSet([\n                            gqlTypes.field(gqlTypes.name('count')),\n                        ])\n                    ),\n                ]),\n                gqlTypes.name(queryType.name),\n                apolloArgs\n            ),\n        ]);\n    }\n\n    if (raFetchMethod === DELETE) {\n        return gqlTypes.document([\n            gqlTypes.operationDefinition(\n                'mutation',\n                gqlTypes.selectionSet([\n                    gqlTypes.field(\n                        gqlTypes.name(queryType.name),\n                        gqlTypes.name('data'),\n                        args,\n                        null,\n                        gqlTypes.selectionSet(fields)\n                    ),\n                ]),\n                gqlTypes.name(queryType.name),\n                apolloArgs\n            ),\n        ]);\n    }\n\n    return gqlTypes.document([\n        gqlTypes.operationDefinition(\n            QUERY_TYPES.includes(raFetchMethod) ? 'query' : 'mutation',\n            gqlTypes.selectionSet([\n                gqlTypes.field(\n                    gqlTypes.name(queryType.name),\n                    gqlTypes.name('data'),\n                    args,\n                    null,\n                    gqlTypes.selectionSet(fields)\n                ),\n            ]),\n            gqlTypes.name(queryType.name),\n            apolloArgs\n        ),\n    ]);\n};\n\nexport const buildFields = (\n    introspectionResults: IntrospectionResult,\n    paths = []\n) => fields =>\n    fields.reduce((acc, field) => {\n        const type = getFinalType(field.type);\n\n        if (type.name.startsWith('_')) {\n            return acc;\n        }\n\n        if (type.kind !== TypeKind.OBJECT && type.kind !== TypeKind.INTERFACE) {\n            return [...acc, gqlTypes.field(gqlTypes.name(field.name))];\n        }\n\n        const linkedResource = introspectionResults.resources.find(\n            r => r.type.name === type.name\n        );\n\n        if (linkedResource) {\n            return [\n                ...acc,\n                gqlTypes.field(\n                    gqlTypes.name(field.name),\n                    null,\n                    null,\n                    null,\n                    gqlTypes.selectionSet([gqlTypes.field(gqlTypes.name('id'))])\n                ),\n            ];\n        }\n\n        const linkedType = introspectionResults.types.find(\n            t => t.name === type.name\n        );\n\n        if (linkedType && !paths.includes(linkedType.name)) {\n            const possibleTypes =\n                (linkedType as IntrospectionUnionType).possibleTypes || [];\n            return [\n                ...acc,\n                gqlTypes.field(\n                    gqlTypes.name(field.name),\n                    null,\n                    null,\n                    null,\n                    gqlTypes.selectionSet([\n                        ...buildFragments(introspectionResults)(possibleTypes),\n                        ...buildFields(introspectionResults, [\n                            ...paths,\n                            linkedType.name,\n                        ])((linkedType as IntrospectionObjectType).fields),\n                    ])\n                ),\n            ];\n        }\n\n        // NOTE: We might have to handle linked types which are not resources but will have to be careful about\n        // ending with endless circular dependencies\n        return acc;\n    }, []);\n\nexport const buildFragments = (introspectionResults: IntrospectionResult) => (\n    possibleTypes: readonly IntrospectionNamedTypeRef<IntrospectionObjectType>[]\n) =>\n    possibleTypes.reduce((acc, possibleType) => {\n        const type = getFinalType(possibleType);\n\n        const linkedType = introspectionResults.types.find(\n            t => t.name === type.name\n        );\n\n        return [\n            ...acc,\n            gqlTypes.inlineFragment(\n                gqlTypes.selectionSet(\n                    buildFields(introspectionResults)(\n                        (linkedType as IntrospectionObjectType).fields\n                    )\n                ),\n                gqlTypes.namedType(gqlTypes.name(type.name))\n            ),\n        ];\n    }, []);\n\nexport const buildArgs = (\n    query: IntrospectionField,\n    variables: any\n): ArgumentNode[] => {\n    if (query.args.length === 0) {\n        return [];\n    }\n\n    const validVariables = Object.keys(variables).filter(\n        k => typeof variables[k] !== 'undefined'\n    );\n    let args = query.args\n        .filter(a => validVariables.includes(a.name))\n        .reduce(\n            (acc, arg) => [\n                ...acc,\n                gqlTypes.argument(\n                    gqlTypes.name(arg.name),\n                    gqlTypes.variable(gqlTypes.name(arg.name))\n                ),\n            ],\n            []\n        );\n\n    return args;\n};\n\nexport const buildApolloArgs = (\n    query: IntrospectionField,\n    variables: any\n): VariableDefinitionNode[] => {\n    if (query.args.length === 0) {\n        return [];\n    }\n\n    const validVariables = Object.keys(variables).filter(\n        k => typeof variables[k] !== 'undefined'\n    );\n\n    let args = query.args\n        .filter(a => validVariables.includes(a.name))\n        .reduce((acc, arg) => {\n            return [\n                ...acc,\n                gqlTypes.variableDefinition(\n                    gqlTypes.variable(gqlTypes.name(arg.name)),\n                    getArgType(arg)\n                ),\n            ];\n        }, []);\n\n    return args;\n};\n\nexport const getArgType = (arg: IntrospectionInputValue): TypeNode => {\n    const type = getFinalType(arg.type);\n    const required = isRequired(arg.type);\n    const list = isList(arg.type);\n\n    if (list) {\n        if (required) {\n            return gqlTypes.listType(\n                gqlTypes.nonNullType(\n                    gqlTypes.namedType(gqlTypes.name(type.name))\n                )\n            );\n        }\n        return gqlTypes.listType(gqlTypes.namedType(gqlTypes.name(type.name)));\n    }\n\n    if (required) {\n        return gqlTypes.nonNullType(\n            gqlTypes.namedType(gqlTypes.name(type.name))\n        );\n    }\n\n    return gqlTypes.namedType(gqlTypes.name(type.name));\n};\n","import { GET_LIST, GET_MANY, GET_MANY_REFERENCE } from 'ra-core';\nimport { IntrospectionResult, IntrospectedResource } from 'ra-data-graphql';\nimport { IntrospectionField } from 'graphql';\nimport { ApolloQueryResult } from '@apollo/client';\n\nexport default (introspectionResults: IntrospectionResult) => (\n    raFetchMethod: string,\n    resource: IntrospectedResource,\n    queryType: IntrospectionField\n) => (response: ApolloQueryResult<any>) => {\n    const data = response.data;\n\n    if (\n        raFetchMethod === GET_LIST ||\n        raFetchMethod === GET_MANY ||\n        raFetchMethod === GET_MANY_REFERENCE\n    ) {\n        return {\n            data: response.data.items.map(sanitizeResource),\n            total: response.data.total.count,\n        };\n    }\n\n    return { data: sanitizeResource(data.data) };\n};\n\nconst sanitizeResource = (data: any) => {\n    const result = Object.keys(data).reduce((acc, key) => {\n        if (key.startsWith('_')) {\n            return acc;\n        }\n\n        const dataForKey = data[key];\n\n        if (dataForKey === null || dataForKey === undefined) {\n            return acc;\n        }\n\n        if (Array.isArray(dataForKey)) {\n            if (typeof dataForKey[0] === 'object' && dataForKey[0] !== null) {\n                return {\n                    ...acc,\n                    [key]: dataForKey.map(sanitizeResource),\n                    [`${key}Ids`]: dataForKey.map(d => d.id),\n                };\n            } else {\n                return { ...acc, [key]: dataForKey };\n            }\n        }\n\n        if (typeof dataForKey === 'object' && dataForKey !== null) {\n            return {\n                ...acc,\n                ...(dataForKey &&\n                    dataForKey.id && {\n                        [`${key}.id`]: dataForKey.id,\n                    }),\n                // We should only sanitize gql types, not objects\n                [key]: dataForKey.__typename\n                    ? sanitizeResource(dataForKey)\n                    : dataForKey,\n            };\n        }\n\n        return { ...acc, [key]: dataForKey };\n    }, {});\n\n    return result;\n};\n","import { IntrospectionResult, BuildQuery } from 'ra-data-graphql';\nimport buildVariables from './buildVariables';\nimport buildGqlQuery from './buildGqlQuery';\nimport getResponseParser from './getResponseParser';\n\nexport const buildQueryFactory = (\n    buildVariablesImpl = buildVariables,\n    buildGqlQueryImpl = buildGqlQuery,\n    getResponseParserImpl = getResponseParser\n) => (introspectionResults: IntrospectionResult): BuildQuery => {\n    const knownResources = introspectionResults.resources.map(r => r.type.name);\n\n    const buildQuery: BuildQuery = (raFetchType, resourceName, params) => {\n        const resource = introspectionResults.resources.find(\n            r => r.type.name === resourceName\n        );\n\n        if (!resource) {\n            throw new Error(\n                `Unknown resource ${resourceName}. Make sure it has been declared on your server side schema. Known resources are ${knownResources.join(\n                    ', '\n                )}`\n            );\n        }\n\n        const queryType = resource[raFetchType];\n\n        if (!queryType) {\n            throw new Error(\n                `No query or mutation matching fetch type ${raFetchType} could be found for resource ${resource.type.name}`\n            );\n        }\n\n        const variables = buildVariablesImpl(introspectionResults)(\n            resource,\n            raFetchType,\n            params,\n            queryType\n        );\n        const query = buildGqlQueryImpl(introspectionResults)(\n            resource,\n            raFetchType,\n            queryType,\n            variables\n        );\n        const parseResponse = getResponseParserImpl(introspectionResults)(\n            raFetchType,\n            resource,\n            queryType\n        );\n\n        return {\n            query,\n            variables,\n            parseResponse,\n        };\n    };\n\n    return buildQuery;\n};\n\nexport default buildQueryFactory(\n    buildVariables,\n    buildGqlQuery,\n    getResponseParser\n);\n","import merge from 'lodash/merge';\nimport buildDataProvider, { BuildQueryFactory, Options } from 'ra-data-graphql';\nimport { DataProvider, Identifier } from 'ra-core';\n\nimport defaultBuildQuery from './buildQuery';\nconst defaultOptions = {\n    buildQuery: defaultBuildQuery,\n};\n\nexport const buildQuery = defaultBuildQuery;\n\nexport default (\n    options: Omit<Options, 'buildQuery'> & { buildQuery?: BuildQueryFactory }\n): Promise<DataProvider> => {\n    return buildDataProvider(merge({}, defaultOptions, options)).then(\n        defaultDataProvider => {\n            return {\n                ...defaultDataProvider,\n                // This provider does not support multiple deletions so instead we send multiple DELETE requests\n                // This can be optimized using the apollo-link-batch-http link\n                deleteMany: (resource, params) => {\n                    const { ids, ...otherParams } = params;\n                    return Promise.all(\n                        ids.map(id =>\n                            defaultDataProvider.delete(resource, {\n                                id,\n                                previousData: null,\n                                ...otherParams,\n                            })\n                        )\n                    ).then(results => {\n                        const data = results.reduce<Identifier[]>(\n                            (acc, { data }) => [...acc, data.id],\n                            []\n                        );\n\n                        return { data };\n                    });\n                },\n                // This provider does not support multiple deletions so instead we send multiple UPDATE requests\n                // This can be optimized using the apollo-link-batch-http link\n                updateMany: (resource, params) => {\n                    const { ids, data, ...otherParams } = params;\n                    return Promise.all(\n                        ids.map(id =>\n                            defaultDataProvider.update(resource, {\n                                id,\n                                data: data,\n                                previousData: null,\n                                ...otherParams,\n                            })\n                        )\n                    ).then(results => {\n                        const data = results.reduce<Identifier[]>(\n                            (acc, { data }) => [...acc, data.id],\n                            []\n                        );\n\n                        return { data };\n                    });\n                },\n            };\n        }\n    );\n};\n","import { ApolloQueryResult } from '@apollo/client';\nimport buildApolloClient, {\n    buildQuery as buildQueryFactory,\n} from 'ra-data-graphql-simple';\nimport { BuildQueryFactory } from 'ra-data-graphql';\nimport { CREATE, DataProvider, DELETE } from 'react-admin';\nimport gql from 'graphql-tag';\nimport { IntrospectionType } from 'graphql';\n\nconst getGqlResource = (resource: string) => {\n    switch (resource) {\n        case 'customers':\n            return 'Customer';\n\n        case 'categories':\n            return 'Category';\n\n        case 'commands':\n            return 'Command';\n\n        case 'products':\n            return 'Product';\n\n        case 'reviews':\n            return 'Review';\n\n        case 'invoices':\n            return 'Invoice';\n\n        default:\n            throw new Error(`Unknown resource ${resource}`);\n    }\n};\n\nconst customBuildQuery: BuildQueryFactory = introspectionResults => {\n    const buildQuery = buildQueryFactory(introspectionResults);\n\n    return (type, resource, params) => {\n        if (type === DELETE) {\n            return {\n                query: gql`mutation remove${resource}($id: ID!) {\n                    remove${resource}(id: $id) {\n                        id\n                    }\n                }`,\n                variables: { id: params.id },\n                parseResponse: ({ data }: ApolloQueryResult<any>) => {\n                    if (data[`remove${resource}`]) {\n                        return { data: { id: params.id } };\n                    }\n\n                    throw new Error(`Could not delete ${resource}`);\n                },\n            };\n        }\n\n        if (resource === 'Customer' && type === CREATE) {\n            return {\n                query: gql`\n                    mutation createCustomer(\n                        $first_name: String!\n                        $last_name: String!\n                        $email: String!\n                        $address: String\n                        $zipcode: String\n                        $city: String\n                        $stateAbbr: String\n                        $birthday: Date\n                        $first_seen: Date!\n                        $last_seen: Date!\n                        $has_ordered: Boolean!\n                        $latest_purchase: Date\n                        $has_newsletter: Boolean!\n                        $groups: [String]!\n                        $nb_commands: Int!\n                        $total_spent: Float!\n                    ) {\n                        createCustomer(\n                            first_name: $first_name\n                            last_name: $last_name\n                            email: $email\n                            address: $address\n                            zipcode: $zipcode\n                            city: $city\n                            stateAbbr: $stateAbbr\n                            birthday: $birthday\n                            first_seen: $first_seen\n                            last_seen: $last_seen\n                            has_ordered: $has_ordered\n                            latest_purchase: $latest_purchase\n                            has_newsletter: $has_newsletter\n                            groups: $groups\n                            nb_commands: $nb_commands\n                            total_spent: $total_spent\n                        ) {\n                            id\n                        }\n                    }\n                `,\n                variables: params.data,\n                parseResponse: ({ data }: ApolloQueryResult<any>) => {\n                    if (data.createCustomer) {\n                        return { data: { id: data.createCustomer.id } };\n                    }\n\n                    throw new Error(`Could not create Customer`);\n                },\n            };\n        }\n\n        return buildQuery(type, resource, params);\n    };\n};\n\nexport default async () => {\n    const dataProvider = await buildApolloClient({\n        clientOptions: {\n            uri: 'http://localhost:4000/graphql',\n        },\n        introspection: {\n            operationNames: {\n                [DELETE]: (resource: IntrospectionType) =>\n                    `remove${resource.name}`,\n            },\n        },\n        buildQuery: customBuildQuery,\n    });\n\n    return new Proxy<DataProvider>(defaultDataProvider, {\n        get: (target, name) => {\n            if (typeof name === 'symbol' || name === 'then') {\n                return;\n            }\n            return async (resource: string, params: any) => {\n                return dataProvider[name](getGqlResource(resource), params);\n            };\n        },\n    });\n};\n// Only used to initialize proxy\nconst defaultDataProvider: DataProvider = {\n    create: () => Promise.reject({ data: null }), // avoids adding a context in tests\n    delete: () => Promise.reject({ data: null }), // avoids adding a context in tests\n    deleteMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n    getList: () => Promise.resolve({ data: [], total: 0 }), // avoids adding a context in tests\n    getMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n    getManyReference: () => Promise.resolve({ data: [], total: 0 }), // avoids adding a context in tests\n    getOne: () => Promise.reject({ data: null }), // avoids adding a context in tests\n    update: () => Promise.reject({ data: null }), // avoids adding a context in tests\n    updateMany: () => Promise.resolve({ data: [] }), // avoids adding a context in tests\n};\n"],"names":["ApolloClient","cache","restore","uri","link","HttpLink","concat","schema","types","queries","resources","query","fetchPolicy","getIntrospectionQuery","then","data","__schema","reduce","name","queryType","mutationType","fields","filter","t","o","map","keys","operationNames","some","find","include","Array","isArray","includes","exclude","r","type","getList","getMany","getManyReference","getOne","create","delete","deleteMany","update","updateMany","resolveIntrospection","introspection","client","clientOptions","buildQuery","override","console","warn","Proxy","get","parseResponse","catch","mutation","variables","mutate","e","networkError","message","statusCode","definitions","length","operation","Error","Promise","resolve","total","kind","ofType","ids","target","id","parseInt","parseFloat","Number","String","Boolean","Object","forEach","args","File","Date","toISOString","inputFields","p","split","pagination","page","perPage","sort","sortField","field","sortOrder","order","a","document","operationDefinition","selectionSet","startsWith","possibleTypes","l","inlineFragment","namedType","argument","variable","variableDefinition","listType","nonNullType","items","count","__typename","join","all","previousData","getGqlResource","resource","customBuildQuery","introspectionResults","buildQueryFactory","params","DELETE","gql","CREATE","createCustomer","buildApolloClient","dataProvider","defaultDataProvider","reject"],"sourceRoot":""}